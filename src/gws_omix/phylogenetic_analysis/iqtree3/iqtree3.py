#!/usr/bin/env python3
# LICENSE
# This software is the exclusive property of Gencovery SAS.
# The use and distribution of this software is prohibited without the prior consent of Gencovery SAS.
# About us: https://gencovery.com

from pathlib import Path
from typing import Final, List, Optional

from gws_core import (
    ConfigParams, ConfigSpecs, File,
    InputSpec, InputSpecs, IntParam, OutputSpec, OutputSpecs,
    ResourceSet, ShellProxy, StrParam, Task, TaskInputs, TaskOutputs,
    BoolParam,
    task_decorator
)

from .iqtree3_env import Iqtree3ShellProxyHelper


@task_decorator(
    "IQTree3",
    human_name="Phylogenetic Tree Construction",
    short_description="Maximum-likelihood phylogenetic tree inference using IQ-TREE"
)

class IQTree3(Task):
    """
    Runs IQ-TREE on an aligned FASTA file and exposes the resulting phylogenetic tree.

    **Input**

    - `aligned_fasta` (File)
      Aligned sequences in FASTA format (classical multiple sequence alignment: all
      sequences have the same length). Typically, this is the output of the MSA
      step (e.g. MAFFT + pyMSAviz).

    IQ-TREE automatically detects the data type (DNA vs protein) from the alignment
    and restricts the model search to appropriate substitution models.

    **Outputs**

    - `tree_file` (File)
      Newick tree file produced by IQ-TREE: `<prefix>.treefile`.
      This is the maximum-likelihood phylogenetic tree, optionally annotated with
      branch support values (if bootstrap is enabled).

    - `iqtree_log` (File)
      IQ-TREE log file: `<prefix>.log` (or, if missing, the wrapper log).
      It contains detailed information about:
        * The selected substitution model (with `-m MFP`),
        * The log-likelihood,
        * Alignment statistics,
        * Estimated model parameters and run settings.

    - `iqtree_outputs` (ResourceSet)
      All additional files generated by IQ-TREE, except for the `.treefile`
      and `.log` which are exposed separately. Examples include:
        * `<prefix>.iqtree`  – main run summary,
        * `<prefix>.ckp.gz`  – checkpoint files,
        * `<prefix>.ufboot`  – bootstrap trees (if requested),
        * and other auxiliary files that may be useful for advanced analyses.

    **Main parameters**

    - `model` (default: `"MFP"`)
      Substitution model. With `"MFP"` (ModelFinder Plus), IQ-TREE automatically
      tests a large set of candidate models (for DNA or protein, depending on the
      alignment) and selects the best-fitting model according to an information
      criterion (e.g. BIC). This is the recommended setting for most users.

    - `bootstrap` (default: `1000`)
      Number of ultrafast bootstrap replicates (UFBoot, option `-bb`).
      * `0`  – no bootstrap (only a single maximum-likelihood tree, no support values).
      * `1000` – recommended value to obtain reliable branch support estimates.

    - `threads` (default: `4`)
      Number of CPU threads used by IQ-TREE (`-nt`). Increasing this value speeds up
      the analysis, up to the number of available cores on the machine.

    **Algorithm (brief overview)**

    1. IQ-TREE reads the aligned FASTA file (`aligned_fasta`) and detects the data type
       (DNA, protein, etc.).
    2. With `-m MFP`, ModelFinder tests a large set of substitution models and selects
       the one that best fits the data.
    3. IQ-TREE performs a maximum-likelihood tree search to infer the best tree
       topology and branch lengths.
    4. If `bootstrap > 0`, IQ-TREE runs ultrafast bootstrap (UFBoot, `-bb`) to estimate
       branch support values based on resampled alignments.
    5. The final tree is written in Newick format to `<prefix>.treefile`, and detailed
       information about the run is written to `<prefix>.log` and `<prefix>.iqtree`.
    """


    # ---------- I/O specs ----------

    input_specs: Final[InputSpecs] = InputSpecs({
        "aligned_fasta": InputSpec(
            File,
            human_name="Aligned sequences (FASTA)",
            short_description="Aligned protein or nucleotide sequences (output of MSA)"
        )
    })

    output_specs: Final[OutputSpecs] = OutputSpecs({
        "tree_file": OutputSpec(
            File,
            human_name="Phylogenetic tree (Newick)"
        ),
        "iqtree_log": OutputSpec(
            File,
            human_name="IQ-TREE log file"
        ),
        "iqtree_outputs": OutputSpec(
            ResourceSet,
            human_name="Additional IQ-TREE outputs"
        ),
    })

    # ---------- configuration ----------

    config_specs: Final[ConfigSpecs] = ConfigSpecs({
        "prefix": StrParam(
            default_value="",
            short_description="Output prefix (default: aligned FASTA filename stem)"
        ),
        "model": StrParam(
            allowed_values=["MFP"],
            default_value="MFP",
            short_description=(
                "Substitution model. MFP (ModelFinder Plus): IQ-TREE teste de "
                "nombreux modèles de substitution et sélectionne automatiquement "
                "le meilleur pour vos données."
            )
        ),
        "bootstrap": IntParam(
            default_value=1000,
            min_value=0,
            short_description=(
                "Nombre de réplicats de bootstrap ultrarapide (UFBoot, -bb). "
                "0 = pas de bootstrap (arbre sans valeurs de support). "
                "1000 est une valeur recommandée pour des supports fiables."
            )
        ),
        "threads": IntParam(
            default_value=4,
            min_value=1,
            short_description="Number of CPU threads for IQ-TREE (-nt)."
        ),
    })

    # ---------- helpers ----------

    def _read_log_tail(self, log_path: Path, max_lines: int = 80) -> str:
        if not log_path.is_file():
            return ""
        try:
            return "\n".join(log_path.read_text(errors="ignore").splitlines()[-max_lines:])
        except Exception:
            return ""

    def _list_dir_files(self, directory: Path) -> str:
        if not directory.is_dir():
            return "<directory does not exist>"
        names: List[str] = sorted(p.name for p in directory.iterdir())
        if not names:
            return "<no files>"
        return "\n".join(names)

    # ---------- main run ----------

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        aligned_fa: File = inputs["aligned_fasta"]

        # Reuse the same env helper as MSAVis (make sure iqtree is installed there)
        shell: ShellProxy = Iqtree3ShellProxyHelper.create_proxy(self.message_dispatcher)

        work_dir = Path(shell.working_dir)
        out_dir = work_dir / "iqtree3"
        out_dir.mkdir(parents=True, exist_ok=True)

        prefix = (params["prefix"] or Path(aligned_fa.path).stem).strip() or "tree"

        # Worker script (wrapper around iqtree)
        worker = Path(__file__).with_name("_iqtree3.py")

        cmd_parts = [
            "python3",
            str(worker),
            "--in",      f"\"{aligned_fa.path}\"",
            "--out",     f"\"{out_dir}\"",
            "--prefix",  f"\"{prefix}\"",
            "--model",   f"\"{params['model']}\"",
            "--bootstrap", str(params["bootstrap"]),
            "--threads",   str(params["threads"]),
            # Note: no seed parameter passed; worker will use its default seed if any.
        ]
        cmd_str = " ".join(cmd_parts)
        print("[DEBUG] IQTree worker cmd:", cmd_str)

        rc = shell.run(cmd_str, shell_mode=True)

        iqtree_rs = ResourceSet()

        # Standard IQ-TREE outputs
        tree_path        = out_dir / f"{prefix}.treefile"
        log_path_iqtree  = out_dir / f"{prefix}.log"
        wrapper_log_path = out_dir / f"{prefix}.iqtree3_wrapper.log"

        # Collect additional outputs (everything starting with prefix* except .treefile & logs)
        for p in sorted(out_dir.glob(f"{prefix}*")):
            if not p.is_file():
                continue
            if p == tree_path:
                continue
            if p == log_path_iqtree:
                continue
            if p == wrapper_log_path:
                continue
            iqtree_rs.add_resource(File(str(p)), p.name)

        # Choose a log to use for debug and as iqtree_log output
        iqtree_log_path: Optional[Path] = None
        if log_path_iqtree.is_file():
            iqtree_log_path = log_path_iqtree
        elif wrapper_log_path.is_file():
            iqtree_log_path = wrapper_log_path

        debug_log_path = iqtree_log_path or wrapper_log_path

        # Error handling
        if rc:
            tail = self._read_log_tail(debug_log_path)
            raise RuntimeError(f"IQ-TREE worker failed. See log tail:\n{tail}")

        if not tree_path.is_file():
            files_list = self._list_dir_files(out_dir)
            tail = self._read_log_tail(debug_log_path)
            raise RuntimeError(
                f"Treefile not found: {tree_path}\n\n"
                f"Files present in {out_dir}:\n{files_list}\n\n"
                f"Log tail:\n{tail}"
            )

        if iqtree_log_path is None or not iqtree_log_path.is_file():
            files_list = self._list_dir_files(out_dir)
            tail = self._read_log_tail(debug_log_path)
            raise RuntimeError(
                "IQ-TREE log file not found.\n\n"
                f"Files present in {out_dir}:\n{files_list}\n\n"
                f"Log tail:\n{tail}"
            )

        tree_file = File(str(tree_path))
        iqtree_log_file = File(str(iqtree_log_path))

        return {
            "tree_file": tree_file,
            "iqtree_log": iqtree_log_file,
            "iqtree_outputs": iqtree_rs,
        }
